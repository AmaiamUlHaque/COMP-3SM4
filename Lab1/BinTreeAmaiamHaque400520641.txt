import java.util.ArrayList;
import java.lang.String;
import java.lang.Math;

public class BinTree {
    private TNode root;
    private int num = 0; //num of code words

    /*
    TIME COMPLEXITY: O(1)
    SPACE COMPLEXITY: O(1)
    - initialisitons and assignments are constants
    */
    public  BinTree() { //constructor 1; creates a tree with only the root node
        root = new TNode(null, null, null);
    }


    
    /*
    TIME COMPLEXITY: O(n*l)
    - where n = number of codewords in array a
    - where l = length of codewords
    - highest order complexity is the nested for loop
    - validates each character (O(n*l)) then inserts each codeword (O(l) each)
    SPACE COMPLEXITY: O(n)
    - where n = number of codewords
    - space for the tree structure storing all codeword nodes
    */
    public BinTree(String[] a) throws IllegalArgumentException { //constructor 2

        int k = a.length; // array length
        
        //check if all items in the array are binary strings
	    //if they are not, throw an exception
            for (int i = 0; i < k; i++){ 
                
                //loop through the current string;
                //if current character is not '0' or '1', throw exception

                int n = a[i].length(); //length of current string

                for (int j = 0; j < n; j++){
                    if (a[i].charAt(j) != '0' && a[i].charAt(j) != '1'){
                        throw new IllegalArgumentException("Invalid argument!");
                    }
                }

            }
    
        //Now, we know that all inputs are binary; 
	    //we start constructing the tree by creating the root node
        this.root = new TNode(null, null,null);
        
	    //loop through the array and insert each codeword by using insertCodeword()  
        for( int i = 0; i < k; i++){
            // insert the codeword a[i] in the tree with corresponding symbol "c" + i
            String symbol = "c" + i;
            insertCodeword(symbol, a[i]);
        }
    }    



    /*
    TIME COMPLEXITY: O(n)
    - where n = length of binary string
    - traverses levels down the tree, creating nodes if needed.
    SPACE COMPLEXITY: O(n)
    - where n = number of nodes created
    - best case: O(0) --> codeword already existed/condition violated
    - avg case: O(1) --> only had to create one node to insert only the codeword node
    - worst case: O(n) --> had to create all new nodes if none existed
    */
    private void insertCodeword(String symbol, String binary) throws IllegalArgumentException {
        
        TNode currNode = this.root; 
        int n = binary.length();
        char c;
	    
        for(int i = 0; i < n; i++){ 

	        c = binary.charAt(i);

            if (c=='0') { //go down left path
                if (currNode.left == null){ //check if left exist
                    currNode.left = new TNode(null, null, null);
                }
                currNode = currNode.left;
            }

            else { //go down right path
                if (currNode.right == null){ //check if right exist
                    currNode.right = new TNode(null, null, null);
                }
                currNode = currNode.right;
            }
            
            if(currNode.data != null) //current node already contains data --> not prefix free
                throw new IllegalArgumentException("Prefix condition violated!");

        }

        if( currNode.left != null || currNode.right != null) {//check if internal node
            throw new IllegalArgumentException("Prefix condition violated!");
        }
        else {
            currNode.data = symbol;
            num++;
        }
        
    }



    /*
    TIME COMPLEXITY: O(n)
    - where n = number of nodes in tree
    - visits every node once for inorder traversal
    SPACE COMPLEXITY: O(h)
    - where h = height of tree
    - recursion depth goes as far as height
    */
    public void printTree(){
        printTree(root);
    }



    /*
    TIME COMPLEXITY: O(n)
    - where n = number of nodes in tree
    - visits every node once for inorder traversal
    SPACE COMPLEXITY: O(h)
    - where h = height of tree
    - recursion depth goes as far as height
    */
    private void printTree(TNode t){
        if (t!=null){
            printTree(t.left);
            if (t.data == null) {
                System.out.print("I "); }
            else {
                System.out.print(t.data + " "); }
            printTree(t.right);
        }
    }



    /*
    TIME COMPLEXITY: O(1)
    - returns a stored counter
    SPACE COMPLEXITY: O(1)
    - returns a stored counter
    */
    public int getNumberOfCodewords(){
        return num;
    }



    /*
    TIME COMPLEXITY: O(n)
    -  where n = number of nodes in the tree
    - visits every node to calculate max depth
    SPACE COMPLEXITY: O(h)
    - where h = height of the tree
    - the max recursion stack depth = max height of tree
    */
    public int height(){
        return height(root);
    }



    /*
    TIME COMPLEXITY: O(n)
    -  where n = number of nodes in the tree
    - visits every node to calculate max depth
    SPACE COMPLEXITY: O(h)
    - where h = height of the tree
    - the max recursion stack depth = max height of tree
    */
    private int height (TNode node){
        if (node == null) return -1; // if tree empty
        if (node.left == null && node.right == null){ //no children
            return(0); //leaf node
        }

        int lHeight = height(node.left);
        int rHeight = height(node.right);

        return ((lHeight > rHeight) ? lHeight : rHeight) + 1;
    }



    /*
    TIME COMPLEXITY: O(n*h) --> O(n^2) --> n and h are proportional to each other
    - where n = number of nodes
    - where h = height of tree
    - visits all nodes for traversal, and their paths are proportional to their heights
    SPACE COMPLEXITY: O(n+h)
    - where n = number of nodes
    - where h = height of tree
    - O(n) for storing all codewords in arraylist
    - O(h) for recursion stack --> not neglible since these trees follow a linear trend (proportional to each other)
    */
    public ArrayList<String> getCodewords(){
        // get all codewords in lexicographical order
        ArrayList<String> codewords = new ArrayList<>();
        getCodewords(root, "", codewords);     
        return codewords;        
    }



    /*
    TIME COMPLEXITY: O(n)
    - where n = number of nodes
    - visits all nodes for traversal
    SPACE COMPLEXITY: O(n) = O(n+h)
    - where n = number of nodes
    - where h = height of tree
    - O(n) for storing all codewords in arraylist
    - O(h) for recursion stack --> not neglible since these trees follow a linear trend
    */
    private void getCodewords(TNode t, String path, ArrayList<String> codewords){
        // store codewords in lexicographical/binary order
        // each item in the list is a str of 0/1s
        // each codeword insertation should be done with an arraylist class method

        if (t!=null){

            //add codeword if leaf node has data
            if (t.data != null) {
                //add codeword to arrayList
                codewords.add(path);
            }
            
            //recursively traverse left (0) then right (1)
            getCodewords(t.left, path+"0", codewords);
            getCodewords(t.right, path+"1", codewords);        
        }

    }



    /*
    TIME COMPLEXITY: O(n)
    - where n = number of chars in s
    - processes each char exactly once
    SPACE COMPLEXITY: O(m)
    - where m = number of decoded symbols --> typically m = h = height of tree
    - stores all decoded symbols
    */
    public ArrayList<String> decode(String s){
        // outputs the sequence of alphabet symbols obtained by decoding the binary sequence s
        // each alphabet symbol has to be stored as a separate item in the list.
        // assume thats is a nonempty, valid binary sequence that can be divided into codewords.

        ArrayList<String> decoded = new ArrayList<>(); //stores decoded result
        TNode currNode = root; //starting point
        int n = s.length();

        for (int i=0; i<n; i++){

            //traverse based on current bit
            if (s.charAt(i) == '0'){
                currNode = currNode.left;
            } 
            else { //(s.charAt(i) == '1')
                currNode = currNode.right;
            }

            //if leaf reached, add symbol and reset to root
            if (currNode != null && currNode.data != null) {
                decoded.add(currNode.data);
                currNode = root; // Reset for next codeword
            }

        }

        return decoded;

    }



    /*
    TIME COMPLEXITY:O(n^2)
    - where n = number of code words
    - calls getCodewords() = (O(n)) and calls decode() (O(n) for EACH  code word
    SPACE COMPLEXITY: O(n)
    - where n = numer and length of codewords
    - stores two codeword arrays and the output string
    - methods invoked within (but outside for loop) also take O(n)
    */
    public String toString(){
        // returns the string representation of the prefix-free code 
        // as a sequence of pairs (symbol, codeword) 
        // listed in increasing order of the symbol index, 
        // separated by empty spaces and ending with an empty space. 
        // For example in lab document, this string is “(c0,10) (c1,0) (c2,111) (c3, 110) ”

        
        ArrayList<String> codewords = getCodewords();

        String[] codewordsInOrder = new String[num]; //stores each pair at its corresponding index

        //map each codeword to its symbol index
        for (int i=0; i<num; i++){

            String codeword = codewords.get(i);
            String decoded = decode(codeword).get(0); //only one item in arraylist --> always at index 0
            String symbolNum = decoded.substring(1); //exclude the char 'c'
            int codeNum = Integer.parseInt(symbolNum);


            String str = "(c" + codeNum + "," + codeword + ") ";
            codewordsInOrder[codeNum] = str;

        }

        String str = "";
        // concatenate in order
        for (int i=0; i<num; i++){
            str += codewordsInOrder[i];
        }

        return str;
    }



    /*
    TIME COMPLEXITY: O(2^h) 
    - where h = height of tree
    - creates array of size 2^(h+1) and fills each index exactly once
    SPACE COMPLEXITY: O(2^h) 
    - where h = height of tree
    - creates array of size 2^(h+1) --> O(2^h)
    - recursive depth of O(h) but insignifcant relative to space for array
    */
    public String[] toArray(){
        int h = height();
        int size = (int) Math.pow(2, h+1); 
        String[] array = new String[size]; //initilase array based on height for maximum number of nodes possible of 2^(h+1)

        fillArray(root, 1, array); //recursively fill array, but skip index 0 for dummy header/index
        return array;
    }



    /*
    TIME COMPLEXITY: O(2^h) 
    - where h = height of tree
    - creates array of size 2^(h+1) and fills each index exactly once
    SPACE COMPLEXITY: O(2^h) 
    - where h = height of tree
    - creates array of size 2^(h+1) --> O(2^h)
    - recursive depth of O(h) but insignifcant relative to space for array
    */
    private void fillArray(TNode node, int index, String[] array) {
        
        // base case: null node or index out of bounds
        if (node == null || index >= array.length) { 
            return;
        }
        
        // store current node value
        array[index] = node.data == null ? "I" : node.data;
        
        // recursively fill children with heap indexing --> left child = 2*i, right child = 2*i+1
        fillArray(node.left, 2*index, array);
        fillArray(node.right, 2*index+1, array); 
    }



}